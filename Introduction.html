<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>1. Introduction</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
html { font-size: 16px; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif; color: rgb(51, 51, 51); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; }
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { padding-bottom: 0.3em; font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { padding-bottom: 0.3em; font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 4px solid rgb(223, 226, 229); padding: 0px 15px; color: rgb(119, 119, 119); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border-top: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; }
table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); }
table tr th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; text-align: left; margin: 0px; padding: 6px 13px; }
table tr td { border: 1px solid rgb(223, 226, 229); text-align: left; margin: 0px; padding: 6px 13px; }
table tr th:first-child, table tr td:first-child { margin-top: 0px; }
table tr th:last-child, table tr td:last-child { margin-bottom: 0px; }
.CodeMirror-lines { padding-left: 4px; }
.code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); }
.md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; }
code { background-color: rgb(243, 244, 244); padding: 0px 2px; }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
.md-mathjax-midline { background: rgb(250, 250, 250); }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; }
.md-tag { color: rgb(167, 167, 167); opacity: 1; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
.html-for-mac .context-menu { --item-hover-bg-color: #E6F0FE; }
#md-notification .btn { border: 0px; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); }





 .typora-export li, .typora-export p, .typora-export,  .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><h1><a name='header-n0' class='md-header-anchor '></a>1. Introduction</h1><h2><a name='header-n2' class='md-header-anchor '></a>1. Self-organizing network</h2><p>  With the rapid development of wireless communication, mobile communication network becomes more and more large-scale to meet the demands of exponential growth of network traffic. To increase the capacity of the network, heterogeneous networks which includes not only the macro cells but also the small cells has received great attention in recent research. However, configuration, optimization and maintenance in such complex and dynamic network become a costly and time-consuming task. In order to solve such a problem, self-organizing networks (SON) have been proposed by Next Generation Mobile Networks (NGMN) and is introduced into the 3G and LTE network [1]. Self-organizing network means that the network can detect the surrounding environment and its changes and can make autonomous decisions including planning, configuration, optimization, calculation, adjustment, testing, error prevention and self-recovery according to the information it detected without the assistance of technical experts. It can improve the network performance, simplify wireless communication network design and reduce network operation and maintenance costs. Through adopting the new advanced wireless measurement technology and self-installation strategy for network autonomous management, the functions of self-configuration, self-optimization, self-healing are realized.</p><h3><a name='header-n4' class='md-header-anchor '></a>1.1 Three functions of SON</h3><p>  As mentioned above, SON covers three parts: self-configuration, self-optimization and self-healing.</p><p>  Self-configuration is the basis of realizing self-organizing function in the wireless access network which works before the wireless access network is put into operation. In the self-configuration phase, each cell in the wireless access network can adjust its own configuration and parameters according to the changes of the network environment for providing the normal operation of the network. The configuration takes place in the pre-operation state. The main use cases of self-configuration include [2]: </p><ul><li>Minimum self-planning parameter set configuration</li><li>Radio frequency parameter self-configuration</li><li>Wireless resource parameter self-configuration </li><li>Cell and neighbor relation self-configuration</li></ul><p>  Self-optimization works in the operation phase of wireless access network. The self-management center collects the performance measurement reports of the users and neighboring cells periodically. After analyzing the collected reports automatically, the management center formulates the corresponding optimization plan and adjusts the relevant configuration parameters of each network operating device adaptively to improve various key performance indicators and resource utilization rate of mobile communication network. The main use cases of self-optimizing include [3]:</p><ul><li>Communication coverage and capacity self-optimization</li><li>Power control self-optimization</li><li>Random access self-optimization</li><li>Handoff self-optimization</li><li>Load balancing self-optimization</li><li>Interference suppression self-optimization</li><li>Congestion control self-optimization</li><li>Packet scheduling parameter self-optimization</li><li>Coverage blind zone self-optimization</li><li>Coverage mismatch of uplink and downlink self-optimization</li><li>Tracking area self-optimization</li><li>Neighbor relation self-optimization</li><li>Energy saving self-optimization</li><li>Joint self-optimization under multiple constraints</li></ul><p>  Self-healing identifies the faults through automatic alarm correlation and performs recovery timely. Self-healing greatly reduces the costs of network maintenance and avoids the bad impact on network quality and user experience. The self-healing also works in the operation phase of wireless access network. The main functions of self-healing are detect and locate network faults and formulate faults handling schemes automatically to compensate the performance degradation caused by network faults. The main use cases of self-healing include:</p><ul><li>Cell outage detection</li><li>Cell outage compensation</li></ul><p>  In summary, the role of self-configuration is to automate network deployment and parameter configuration. The purpose of self-optimization is to guarantee that the network may operate in a optimal state. Self-healing which will be mainly discussed in this paper is to mitigate the effect of the network faults.</p><h3><a name='header-n51' class='md-header-anchor '></a>1.2 The architectures of SON</h3><p>  The deployment modes of self-organizing functions in the wireless access network can be divided into three categories : centralized deployment, distributed deployment and hybrid deployment. The three deployment modes are introduced as follows.</p><ol start='' ><li>Centralized deployment</li></ol><p>  In this deployment mode, the functions of self-configuration, self-optimization and self-healing are implemented in one node called operation and management entity (OAM) which is responsible for the operation, maintenance, and management of the communication network. The information interaction between cells is completed through OAM and each cell only needs to generate key performance indicator measurement reports and exchange some basic information. On the one hand, the centralized deployment mode reduces the complexity of the functions and structures of each cell and greatly improves the efficiency of cooperation between the cells. On the other hand, this mode can get a wide range of data so it can consider more comprehensive factors when optimize and configurate the network parameters. But this deployment mode is limited by the processing capacity of the OAM in terms of network capacity, so there are obvious defects of the robustness, load capacity and scalability of the network. </p><ol start='2' ><li>Distributed deployment</li></ol><p>  In the distributed deployment, all the functions of self-organizing are implemented in the base stations of the cells. In this way, information can be exchanged directly between cells which can not only greatly improve the processing velocity and efficiency but also distribute and share the processed data quickly. However, this deployment mode may lead to a complicated functional structure of the cell and reduce the efficiency of cooperation among cells. Besides, this kind of architecture is difficult to support large-scale network optimization schemes and may increase the costs of network deployment.</p><ol start='3' ><li>Hybrid deployment</li></ol><p>  In hybrid deployment, SON functions are distributed among OAM and base stations of cells. Some parts of SON functions are separated from OAM and are implemented in the base stations of cells. OAM retains the functions such as cell request authorization, issuing processing schemes and so on. The hybrid deployment combines the advantages of centralized and distributed deployments but inherits the disadvantages of two deployments inevitably. </p><p>  The above three self-organizing deployment modes have their own advantages and all of them can be used in wireless access network. However, due to the differences in load ability, information interaction types and scalability requirements of each cell, the actual deployment should consider the basic characteristics, functional requirements, network environment of the use case and make a decision. In this paper, the centralized deployment is adopted for simplicity. </p><h2><a name='header-n66' class='md-header-anchor '></a>2. Self-healing</h2><p>  Self-healing refers to recovering the network from the faults by monitoring network conditions and take corresponding reconfiguration actions to guarantee the basic network operation maximally. As a main component of SON, self-healing which is composed of cell outage detection and cell outage compensation [4], aims to enhance the robustness and efficiency of the mobile wireless network. The cell outage means the total loss of radio services in the coverage area of a cell, which can seriously affect the network performance and user experience. Cell outage detection and cell outage compensation are introduced as follows.</p><h3><a name='header-n68' class='md-header-anchor '></a>2.1 Cell outage detection</h3><p>  Cell outage detection means that detecting the faults of the network by analyzing the collected related measurement reports containing the key performance indicators of network. The measurement reports can obtain from base stations or user equipments (UEs) [5].</p><p>   (1) The measurements from base stations:</p><ul><li><p>Cell load condition</p></li><li><p>Radio Link Failure counter </p></li><li><p>Handover failure rate</p></li><li><p>Call blocking/dropping rate</p></li><li><p>Cell throughput and average user throughput</p><p>(2) The measurements from user equipments:</p></li><li><p>Reference Signal Received Power (RSRP)</p></li><li><p>Connection or handover failure report</p></li><li><p>Carrier to Interference Ratio (CIR)</p></li></ul><p>  The measurement reports can be collected periodically or based on event triggering. For cell outage detection, only parts of the above measurements are considered in order to avoid making the detection algorithm design complex. </p><h3><a name='header-n90' class='md-header-anchor '></a>2.2 Cell outage compensation</h3><p>  Once the cell outage is detected, cell outage compensation is triggered. Cell outage compensation means that providing communication services to users of outage cell by adjusting antenna parameters of compensation cells to increase the cell coverage. In this process, due to the complexity of UEs distribution, some user equipments in outage cell may not be covered so complete compensation may not be possible. Through cell outage compensation, the network performance degradation can be decreased. Figure 1 shows an example of cell outage compensation under SON centralized deployment. From the figure, we can see that the central cell with shadow is the outage cell which can not provide the communication service to the UEs in it. The OAM detects the cell outage and adjusts the relevant antenna parameters of the surrounding cells to provide communication coverage to the UEs in the outage cell.</p><p>  <img src='file:///C:\Users\ZHAOMI~1\AppData\Local\Temp\Hnc\BinData\EMB0000288c2bb2.png' alt='img' referrerPolicy='no-referrer' />  </p><center>Fig.1. An example of cell outage compensation</center><p>  Traditionally, cell outage management has been manually performed but it has become unpractical as the network becomes more sophisticated. Instead of relying on highly experienced network operator, intelligent and automated network which utilizes machine learning method for the complicated network operation has become a trend. Machine learning algorithms can be mainly classified into three categories: supervised, unsupervised and reinforcement learning. Supervised learning requires a supervisor to train the system with guidance. Unsupervised learning learns by itself without any supervisor and guidance. Reinforcement learning which also learns by itself is a method that tries to maximize rewards by selecting any action in an environment [6].</p><p>  The contributions of this paper are as follows:</p><p>  1) A complete cell outage management framework is designed</p><p>  2) A fast and reliable cell outage detection method which is based on DBSCAN is proposed</p><p>  3) DQN algorithm is applied for cell outage compensation</p><p>  In this paper, machine learning algorithms are adopted to implement the cell outage management. In the cell outage management process, DBSCAN is used to detect the cell outage of a macro cell and DQN is applied in a pico cell to compensate the cell outage. In Section 2, the related work of cell outage management is introduced. Section 3 includes the description of the system model. In Section 4, the proposed algorithms are introduced and simulation results are given in Section 5. Finally, conclusion is drawn in Section 6.</p><h1><a name='header-n101' class='md-header-anchor '></a>2. Related Work</h1><p>  As one of the key technologies of SON, self-healing has aroused many attentions in mobile communication network research. The goal of self-healing is to detect failures that affect the network performance in an automatic, quick and accurate way and to recover from the faults automatically. </p><p>  An approach is proposed to detect the cell outage using neighbor cell list reports in [7]. The authors use neighbor cell list reports which are collected from UEs to build a dynamic relational graph among cells and through observing the changes of the graph to detect the cell outage. But as the communication system is becoming more complicated and the number of UEs is increasing rapidly, building a dynamic graph of all the cells will be so difficult and will occupy lots of storage space which will make this method unpractical.</p><p>  On the other hand, the authors in [8] build a model based on K-NN algorithm to detect the cell outage through cooperation between the outage cell and neighbor cells in a heterogenous network. But the determination of K value is not easy because the distribution of UEs and communication environment change constantly.</p><p>  Onireti et al.,in [9] perform cell outage detection using two different algorithms which are K-NN and Local Outlier Factor based Anomaly Detector (LOFAD). The authors found that the K-NN algorithm is better than LOFAD for its higher detection accuracy. So it&#39;s also difficult to determine the value of K to detect the outage. Besides, the authors also use a Actor-Critic (AC) algorithm which is a reinforcement learning algorithm to perform the cell outage compensation. However, the convergence of the AC algorithm is slow and hard. </p><p>  In [10], the authors propose a method to detect the cell outage by collecting and analyzing the handover statistics. But not all the UEs in macro cell would hand off, in some circumstances it&#39;s difficult to obtain the handover statistics of UEs. As a result, it&#39;s also not a good method for cell outage detection especially for the macro cells.  </p><p>  In [11], the authors employ diffusion maps to perform the dimension reduction and then use K-means to detect the cell outage. However, as a nonlinear dimension reduction method, diffusion maps has a relatively higher calculation complexity. K-means algorithm needs to determine the K value which represents the number of clusters before clustering. Besides, K-means is sensitive to the initial value of the center point.</p><p>  Saeed et al., in [12], employ a fuzzy reinforcement learning algorithm to perform cell outage compensation by controlling the antenna downtilt and transmit power. However, considering the high algorithm complexity and slow convergence speed of fuzzy reinforcement learning, this method is not suitable for cell outage compensation which has critical real-time requirements.</p><p>  On the other hand, in [13], the authors use genetic algorithm combined with immune algorithm to achieve the cell outage compensation by adjusting the uplink target received power in surrounding cells. This method also has a high computational complexity and is difficult to realize fast cell outage compensation. </p><p>  Finally in [14], the authors employ an dynamic affinity propagation algorithm to perform the cell outage detection. But the time and space complexity of this method is also relatively high. So it&#39;s unsuitable for massive data analysis.</p><p>  Considering the disadvantages of these proposed methods, in this paper, a new cell outage management framework is proposed. For cell outage detection, DBSCAN is applied which has relatively low computational complexity and does not need to determine the number of clusters before clustering. For cell outage compensation, DQN is used which combines the advantages of neural network and Q-learning algorithms and is able to handle large-scale state space.</p><h1><a name='header-n114' class='md-header-anchor '></a>3. Proposed System Model Overview</h1><p>  </p><p><img src='file:///C:\Users\ZHAOMI~1\AppData\Local\Temp\Hnc\BinData\EMB0000288c2bb1.png' alt='img' referrerPolicy='no-referrer' />  </p><center> Fig.2. The overview of cell outage management framework</center><p>  As mentioned above, the cell outage management is mainly composed of the following two parts: cell outage detection and cell outage compensation. Figure 2 shows the framework of cell outage management. The outage detection and compensation are implemented in an operation and management entity which collects the Minimization of Drive-Test (MDT) reports UEs of cells and then runs the detection and compensation algorithms. In this study, user equipments are configured to perform and report the measures periodically. The measurements of user equipments are listed in Table 1.</p><center>Table 1. MDT Reported Measurements</center><figure><table><thead><tr><th>Measurement</th><th>Description </th></tr></thead><tbody><tr><td>Location</td><td>Longitude and Latitude Information</td></tr><tr><td>Serving Cell Information</td><td>Cell Global Identification</td></tr><tr><td>RSRP</td><td>Reference Signal Received Power</td></tr><tr><td>CIR</td><td>Carrier to Interference Ratio</td></tr><tr><td>Neighboring Cell Information</td><td>RSRP and CIR of Neighbor Cells</td></tr></tbody></table></figure><p>  After gathering the reports from UEs, the features are extracted in the profiling phase. We select two features to perform the detection work which are carrier-to-interference ratio (CIR) and reference signal received power (RSRP). Then these two features are fed into the detection module running the DBSCAN clustering algorithm to detect the outage. If the outage of any macro cell is detected, the compensation procedure will be triggered. The DQN algorithm will be performed in a pico cell by adjusting the antenna parameters to compensate the outage of the macro cell. The flowchart of the whole process is given as follows.</p><p>                                     <img src='file:///C:\Users\ZHAOMI~1\AppData\Local\Temp\Hnc\BinData\EMB0000288c2bb0.png' alt='img' referrerPolicy='no-referrer' />  </p><center>Fig.3. Cell outage management flowchart</center><h1><a name='header-n182' class='md-header-anchor '></a>4. Proposed Method</h1><h2><a name='header-n183' class='md-header-anchor '></a>1. DBSCAN and Cell Outage Detection</h2><p>  In the cell outage detection phase, the DBSCAN algorithm is applied to cluster the data in order to find anomalies. DBSCAN is a clustering algorithm which is proposed in [15]. Given a set of points in the space, it can cluster the points into groups that are closely packed and mark the outlier points according to the density. DBSCAN describes the proximity of the sample set based on density. In DBSCAN, <em>ε</em> and minPts are used to describe the proximity of the sample distribution. <em>ε</em>, called radius, refers to the neighborhood distance threshold of a sample. And minPts refers to the threshold of the size of a sample in the neighborhood within distance <em>ε</em>. Besides, several concepts which are directly density-reachable, density-reachable and density-connected are introduced as follows. Suppose that some points are to be clustered. A point t is considered as a core point if there is a circle with center t whose radius is <em>ε</em> contains at least minPts points (including t). The points except t are supposed to be directly density-reachable from point t. On the other hand, a point u is density-reachable from t if exists a sequence from t1 to tn with t1=t and tn=u, in which each ti+1 is directly density-reachable from ti and all the points in the sequence should be core points except u. Two points are considered to be density-connected if there is a core point v that both the two points are density-reachable from point v. As a result, all points which are density-connected are regarded as a cluster.</p><p>  As mentioned above, the MDT report data can be extracted as a two-dimensional data vector in the form of {CIR,RSRP} in the profiling phase which are the input of the detection algorithm. Euclidean distance is adopted for the clustering task. Figure 4 shows an example of cell outage detection based on DBSCAN.</p><p>  <img src='file:///C:\Users\ZHAOMI~1\AppData\Local\Temp\Hnc\BinData\EMB0000288c2baf.png' alt='img' referrerPolicy='no-referrer' />  </p><center>Fig.4. An example of cell outage detection</center><p>  The values of features in outage cell are different from the values in normal cell. So the DBSCAN is able to find the anomaly cluster and we can confirm that the cell outage occurs. The system then will start the compensation process. The advantages of using DBSCAN for clustering are as follows:</p><p>  (1) Fast clustering speed and efficient discovery of clusters with arbitrary shape</p><p>  (2) Self-decision on the optimal number of clusters to be established  (a big difference from the K-means clustering method)                                                                    </p><p>  (3) Unbiased shape of clusters</p><p>  (4) Allowance of inputting filter noise parameters if necessary</p><h2><a name='header-n207' class='md-header-anchor '></a>2. Deep Q Network and Cell Outage Compensation</h2><p>  Deep Q Network is a combination of Q learning which is a kind of reinforcement learning and Neural Network. So before describing DQN, let us observe reinforcement learning and neural network first.</p><p>  <img src='file:///C:\Users\ZHAOMI~1\AppData\Local\Temp\Hnc\BinData\EMB0000288c2bae.png' alt='img' referrerPolicy='no-referrer' />  </p><center>Fig.5. Deep Q Network</center><h3><a name='header-n218' class='md-header-anchor '></a>2.1 Reinforcement Learning</h3><p>  Reinforcement learning is a machine learning method which concerns what actions agents take in an environment to maximize the cumulative rewards. At the beginning, the environment gives a state to the agent and the agent selects actions according to the policy. Then the environment sends a new state and gives a reward to the agent associated with the transition. The agent updates the policy and evaluate the action it took. This loop continues until the environment sends a terminal state to end the process. Figure 6 shows the process of the reinforcement learning.</p><p>  <img src='file:///C:\Users\ZHAOMI~1\AppData\Local\Temp\Hnc\BinData\EMB0000288c2bad.png' alt='img' referrerPolicy='no-referrer' />  </p><center>Fig.6. Reinforcement learning process</center><p>  However, the agent does not know which action should be taken to get the highest reward at the beginning. So the agent may try some actions randomly for a while to learn from the rewards it received. After that, the agent selects the action according to updated policy, which can highly likely bring the highest reward.</p><p>  Q-learning algorithm is a model-free reinforcement learning algorithm proposed by Watkins. It is an adaptation of the Q-Value iteration algorithm to the situation where the transition probabilities and the rewards are initially unknown. The main feature of Q-learning is that it has a Q value table which stores the corresponding rewards for all state-action pairs. Based on this table, the Q-learning system selects the action with the highest reward. After that, the system updates the Q value according to the earned reward and the maximum reward we can expect in the new state. The equation of the Q-learning is as follows.</p><p>                                              <img src='file:///C:\Users\ZHAOMI~1\AppData\Local\Temp\DRW0000288c2bc0.gif' alt='img' referrerPolicy='no-referrer' />                               (1)</p><p>  For each state-action pair (s,a), the algorithm records a running average of the rewards R the agent gets while giving the state s with action a, plus the rewards it expects to get in the future. Because the target policy would act optimally, the maximum of the Q-value estimate is selected for the next state. The algorithm diagram is given as follows.     </p><p>    <img src='file:///C:\Users\Zhao Minghao\AppData\Roaming\Tencent\Users\279516518\QQ\WinTemp\RichOle\$687L}PX7H}EGA1STBDEF$Q.png' alt='img' referrerPolicy='no-referrer' />  </p><center>Fig.7. Q-learning algorithm diagram</center><p>&nbsp;</p></div>
</body>
</html>